Problem 1
Imported "OrderedDict" function from Collections module because it is a dictionary that remembers the order that items are added/inserted, 
which allows for O(1) lookup/insertion/deletion. Space complexity is O(n), no additional storage needed for solution. 
Source: https://docs.python.org/3/library/collections.html#collections.OrderedDict 

Problem 2
This problem is best solved with recursion, which  causes the space complexity to rise to O((function calls)*(n)).
For time, it is dependant on the number of directories and files, so O(directories * files).  

Problem 3
Huffman algorithm has a time complexity of O(nlogn), and space complexity for this tree is O(k) where k = # of symbols in the encoded data.
Source: https://www.programiz.com/dsa/huffman-coding. 

Problem 4
This problem can be solved as P2 was, with recursion. The space complexity is O((function calls)*(n)).
For time, it is dependant on the number of groups and users, so O(groups * users).  

Problem 5
Blockchain implemented with a linked list  with a pointer at the head and tail, so adding at the tail 
is O(1) in time and not O(n), and space complexity is O(n).

Problem 6
Linked Lists were the obvious choice after reading the instructions for this
question. The creation of separate linked list for union/intersection linked lists
have space and time complexity of O(n).